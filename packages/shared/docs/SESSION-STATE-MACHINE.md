# Session State Machine: RH → LH → RH

## Overview

The session state machine implements the core learning flow for the Hemisphere app, based on McGilchrist's RH→LH→RH cognitive circuit. Every learning session progresses through three sequential stages:

1. **ENCOUNTER** (RH-Primary): Narrative hook, spatial overview, emotional anchor
2. **ANALYSIS** (LH-Primary): Decomposition, retrieval practice, categorization
3. **RETURN** (RH-Primary): Reconnection, transfer challenge, creative synthesis

This state machine enforces stage transitions, timing constraints, and completion criteria to ensure the pedagogical integrity of the learning experience.

## Architecture

### State Machine Diagram

```
[PLANNING] ──────────> [READY]
                          │
                          │ START_SESSION
                          ▼
                    [IN_PROGRESS]
                          │
    ┌─────────────────────┼─────────────────────┐
    │                     │                     │
    │ ENCOUNTER    →   ANALYSIS    →   RETURN  │
    │ (RH-Primary)     (LH-Primary)   (RH-Primary)
    │  3-4 min          6-10 min       3-4 min │
    │                                           │
    └───────────────────┬───────────────────────┘
                        │
          COMPLETE_SESSION / ABANDON_SESSION
                        │
                        ▼
              [COMPLETED / ABANDONED]
```

### Session Status Lifecycle

```
planning → ready → in_progress ⇄ paused → completing → completed
                       │
                       └──────────────────> abandoned
```

## States

### Session Status

| Status | Description | Valid Transitions |
|--------|-------------|-------------------|
| `planning` | Session plan being generated by content selection algorithm | → `ready` |
| `ready` | Session plan ready, item queue populated, not yet started | → `in_progress` |
| `in_progress` | Session actively running, learner progressing through stages | → `paused`, `abandoned`, `completing` |
| `paused` | Session temporarily paused by learner | → `in_progress` |
| `completing` | Return stage complete, finalizing session data | → `completed` |
| `completed` | Session fully completed, data persisted | (terminal state) |
| `abandoned` | Session started but not completed within timeout | → `in_progress` (resume) |

### Session Stages

| Stage | Hemisphere | Duration | Activities |
|-------|-----------|----------|------------|
| `encounter` | RH-Primary | 3-4 min | Narrative hook, spatial overview, emotional anchor, curiosity gap |
| `analysis` | LH-Primary | 6-10 min | Decomposition, retrieval practice, categorization, feedback loops |
| `return` | RH-Primary | 3-4 min | Reconnection, transfer challenge, creative synthesis, reflection |

### Stage Substates (within `in_progress`)

When `status === 'in_progress'`, the `currentStage` field indicates the active stage:
- `currentStage === 'encounter'`: Learner in Encounter stage
- `currentStage === 'analysis'`: Learner in Analysis stage
- `currentStage === 'return'`: Learner in Return stage

## Events

The state machine responds to the following events:

### Core Events

```typescript
type SessionEvent =
  | { type: 'START_SESSION'; sessionId: string; timestamp: number }
  | { type: 'PAUSE_SESSION'; timestamp: number }
  | { type: 'RESUME_SESSION'; timestamp: number }
  | { type: 'COMPLETE_ACTIVITY'; activityId: string; timestamp: number }
  | { type: 'ADVANCE_STAGE'; timestamp: number }
  | { type: 'SKIP_STAGE'; reason: string; timestamp: number }
  | { type: 'COMPLETE_SESSION'; timestamp: number }
  | { type: 'ABANDON_SESSION'; reason: string; timestamp: number }
  | { type: 'RESUME_ABANDONED'; timestamp: number };
```

### Event Descriptions

- **START_SESSION**: Transition from `ready` to `in_progress`, begin Encounter stage
- **PAUSE_SESSION**: Pause active session, stop duration tracking
- **RESUME_SESSION**: Resume paused session, continue duration tracking
- **COMPLETE_ACTIVITY**: Mark an activity (content item) as complete, advance item index
- **ADVANCE_STAGE**: Advance from Encounter→Analysis or Analysis→Return (with guard validation)
- **SKIP_STAGE**: Manual override to skip current stage (debugging/admin only)
- **COMPLETE_SESSION**: Complete Return stage and finalize session
- **ABANDON_SESSION**: Abandon session (timeout, user quit, error)
- **RESUME_ABANDONED**: Resume previously abandoned session

## Guard Conditions

Guards are predicates that must be satisfied before a transition can occur.

### `canStartSession`

**Condition:**
- `status === 'ready'`
- `itemQueue.length > 0`

**Reason:** Session plan must exist before starting

---

### `canAdvanceToAnalysis`

**Conditions:**
- `currentStage === 'encounter'`
- `encounterComplete === true`
- `encounterDurationMs >= minEncounterDurationMs` (default: 3 min)

**Reason:** Ensure minimum engagement time in Encounter before moving to focused practice

---

### `canAdvanceToReturn`

**Conditions:**
- `currentStage === 'analysis'`
- `analysisComplete === true`
- `analysisDurationMs >= minAnalysisDurationMs` (default: 6 min)
- `currentItemIndex > 0` (at least one item completed)

**Reason:** Ensure meaningful practice occurred before synthesis stage

---

### `canCompleteSession`

**Conditions:**
- `currentStage === 'return'`
- `returnComplete === true`
- `returnDurationMs >= minReturnDurationMs` (default: 3 min)

**Reason:** Ensure learner engages with synthesis and reflection

---

### `canPauseSession`

**Conditions:**
- `status === 'in_progress'`
- `pausedAt === null`

**Reason:** Can only pause active, non-paused session

---

### `canResumeSession`

**Conditions:**
- `status === 'paused' || status === 'abandoned'`

**Reason:** Can resume paused or abandoned sessions

## Transitions

### Valid Transitions

| From State | Event | Guard | To State |
|-----------|-------|-------|----------|
| `ready` | `START_SESSION` | `canStartSession` | `in_progress` (Encounter) |
| `in_progress` (Encounter) | `ADVANCE_STAGE` | `canAdvanceToAnalysis` | `in_progress` (Analysis) |
| `in_progress` (Analysis) | `ADVANCE_STAGE` | `canAdvanceToReturn` | `in_progress` (Return) |
| `in_progress` (Return) | `COMPLETE_SESSION` | `canCompleteSession` | `completed` |
| `in_progress` | `PAUSE_SESSION` | `canPauseSession` | `paused` |
| `paused` | `RESUME_SESSION` | `canResumeSession` | `in_progress` |
| `in_progress` | `ABANDON_SESSION` | (none) | `abandoned` |
| `abandoned` | `RESUME_ABANDONED` | `canResumeSession` | `in_progress` |

### Invalid Transitions

The state machine will return an error for invalid transitions:
- Starting a session that is not `ready`
- Advancing a stage when guard conditions are not met
- Completing a session before Return stage is complete
- Pausing an already paused session

## Configuration

### Default Configuration

Based on instructional design (12-18 min total session):

```typescript
{
  minEncounterDurationMs: 180_000,    // 3 min
  minAnalysisDurationMs: 360_000,     // 6 min
  minReturnDurationMs: 180_000,       // 3 min

  targetEncounterDurationMs: 240_000, // 4 min
  targetAnalysisDurationMs: 600_000,  // 10 min
  targetReturnDurationMs: 240_000,    // 4 min

  maxPauseDurationMs: 1_800_000,      // 30 min
  requireAllActivitiesComplete: false // Allow flexible pacing
}
```

### Customization

The configuration can be customized per session type:
- **Standard sessions**: Default config
- **Review sessions**: Shorter Encounter (1 min), longer Analysis (12 min)
- **Diagnostic sessions**: Equal stage durations (5 min each)

## Usage Examples

### 1. Starting a Session

```typescript
import { sessionStateReducer, createInitialSessionState } from '@hemisphere/shared';

// Create initial state
const initialState = createInitialSessionState({
  sessionId: 'session-123',
  userId: 'user-456',
  topicId: 'topic-789',
  sessionType: 'standard',
  itemQueue: ['item-1', 'item-2', 'item-3'],
  plannedBalance: { newItemCount: 2, reviewItemCount: 1, interleavedCount: 0 }
});

// Start session
const result = sessionStateReducer(initialState, {
  type: 'START_SESSION',
  sessionId: 'session-123',
  timestamp: Date.now()
});

if (result.success) {
  console.log('Session started:', result.newState.currentStage); // 'encounter'
} else {
  console.error('Failed to start:', result.error, result.reason);
}
```

### 2. Advancing Through Stages

```typescript
// Complete Encounter activities
let state = result.newState;

// Mark encounter as complete (in your UI logic)
state = { ...state, encounterComplete: true };

// Advance to Analysis
const advanceResult = sessionStateReducer(state, {
  type: 'ADVANCE_STAGE',
  timestamp: Date.now()
});

if (advanceResult.success) {
  state = advanceResult.newState;
  console.log('Advanced to:', state.currentStage); // 'analysis'
}
```

### 3. Handling Activity Completion

```typescript
// Learner completes an activity
const completeResult = sessionStateReducer(state, {
  type: 'COMPLETE_ACTIVITY',
  activityId: 'item-1',
  timestamp: Date.now()
});

if (completeResult.success) {
  state = completeResult.newState;
  console.log('Items completed:', state.completedActivityIds.length);
  console.log('Current item index:', state.currentItemIndex);
}
```

### 4. Pause and Resume

```typescript
// Pause session
const pauseResult = sessionStateReducer(state, {
  type: 'PAUSE_SESSION',
  timestamp: Date.now()
});

// Later, resume
const resumeResult = sessionStateReducer(pauseResult.newState, {
  type: 'RESUME_SESSION',
  timestamp: Date.now()
});
```

### 5. Completing a Session

```typescript
// Mark return stage as complete
state = { ...state, returnComplete: true };

// Complete session
const completeResult = sessionStateReducer(state, {
  type: 'COMPLETE_SESSION',
  timestamp: Date.now()
});

if (completeResult.success) {
  console.log('Session completed!');
  console.log('Total duration:', completeResult.newState.totalDurationMs);
}
```

## Integration with Zustand

The reducer can be used directly in a Zustand store:

```typescript
import { create } from 'zustand';
import { sessionStateReducer, type SessionState, type SessionEvent } from '@hemisphere/shared';

interface SessionStore {
  session: SessionState | null;
  send: (event: SessionEvent) => void;
  error: string | null;
}

export const useSessionStore = create<SessionStore>((set, get) => ({
  session: null,
  error: null,

  send: (event) => {
    const currentSession = get().session;
    if (!currentSession) {
      set({ error: 'No active session' });
      return;
    }

    const result = sessionStateReducer(currentSession, event);

    if (result.success) {
      set({ session: result.newState, error: null });
    } else {
      set({ error: `${result.error}: ${result.reason}` });
      console.error('State machine error:', result);
    }
  }
}));
```

## Progress Tracking

The state machine includes utilities for calculating progress:

```typescript
import { calculateStageProgress, calculateSessionProgress } from '@hemisphere/shared';

// Get current stage progress (0-1)
const stageProgress = calculateStageProgress(state);

// Get overall session progress (0-1)
const sessionProgress = calculateSessionProgress(state);

// Display progress
console.log(`Stage: ${Math.round(stageProgress * 100)}%`);
console.log(`Session: ${Math.round(sessionProgress * 100)}%`);
```

## Validation

Validate state consistency at any time:

```typescript
import { validateSessionState } from '@hemisphere/shared';

const errors = validateSessionState(state);

if (errors.length > 0) {
  console.error('State validation errors:', errors);
} else {
  console.log('State is valid');
}
```

## Error Handling

The reducer returns a `TransitionResult`:

```typescript
type TransitionResult =
  | { success: true; newState: SessionState }
  | { success: false; error: string; reason: string };
```

Common error types:
- `INVALID_TRANSITION`: Attempted transition not allowed from current state
- `INVALID_STATE`: State is inconsistent or missing required data
- `GUARD_FAILED`: Guard condition not met (e.g., minimum duration)
- `UNKNOWN_EVENT`: Event type not recognized
- `REDUCER_ERROR`: Unexpected error in reducer logic

Always check `result.success` before using `result.newState`.

## Analytics and Tracking

The state machine supports comprehensive session analytics:

```typescript
import { type SessionSummary } from '@hemisphere/shared';

// After session completion, generate summary
const summary: SessionSummary = {
  sessionId: state.sessionId,
  userId: state.userId,
  topicId: state.topicId,
  status: state.status,
  startedAt: state.startedAt!,
  completedAt: state.completedAt,
  totalDurationMs: state.totalDurationMs,
  encounterDurationMs: state.encounterDurationMs,
  analysisDurationMs: state.analysisDurationMs,
  returnDurationMs: state.returnDurationMs,
  totalItems: state.itemQueue.length,
  completedItems: state.completedActivityIds.length,
  completionRate: state.completedActivityIds.length / state.itemQueue.length,
  abandonedAtStage: state.abandonedAtStage,
  abandonmentReason: state.abandonmentReason
};

// Send to analytics
trackSessionCompletion(summary);
```

## Testing

The state machine is a pure reducer, making it easy to test:

```typescript
import { test, expect } from 'vitest';
import { sessionStateReducer, createInitialSessionState } from '@hemisphere/shared';

test('should start session from ready state', () => {
  const state = createInitialSessionState({
    sessionId: 'test-session',
    userId: 'test-user',
    topicId: 'test-topic',
    sessionType: 'standard',
    itemQueue: ['item-1'],
    plannedBalance: { newItemCount: 1, reviewItemCount: 0, interleavedCount: 0 }
  });

  const result = sessionStateReducer(state, {
    type: 'START_SESSION',
    sessionId: 'test-session',
    timestamp: Date.now()
  });

  expect(result.success).toBe(true);
  if (result.success) {
    expect(result.newState.status).toBe('in_progress');
    expect(result.newState.currentStage).toBe('encounter');
  }
});
```

## Future Enhancements

Potential extensions to the state machine:

1. **Adaptive stage durations**: Adjust minimum durations based on learner history
2. **Interrupt recovery**: Save state to Redis/localStorage for crash recovery
3. **Multi-session arcs**: Track progress across related sessions
4. **Stage branching**: Allow alternative paths (e.g., diagnostic → remediation)
5. **Event sourcing**: Persist all events for replay and debugging

## References

- Instructional Design Doc: `/docs/design/03-instructional-design.md`
- Technical Architecture: `/docs/architecture/07-technical-architecture.md`
- Database Schema: `/packages/db/src/schema/sessions.ts`
